---
layout: post
title: C++
categories: [cpp]
---


## 前言

纯c打算法竞赛还是太吃操作了，python又不让用，博主博主，有没有什么既不吃操作又竞赛友好的语言吗？

有的兄弟，有的。接下来让我隆重推出————c plus plus！

## 数据类型

C++ 在 C 语言的基础上增加了多种数据类型和类型特性，主要区别如下：

---

### **1. 布尔类型（`bool`）**
- **C 语言**：无原生布尔类型，通常用 `int` 代替（`0` 表示假，非 `0` 表示真）。
- **C++**：引入 `bool` 类型，支持 `true` 和 `false`。
  ```cpp
  bool flag = true; // C++ 特有
  ```

---

### **2. 字符串类型（`std::string`）**
- **C 语言**：以 `'\0'` 结尾的字符数组（`char*`），需手动管理内存。
- **C++**：提供 `std::string` 类，支持自动内存管理、拼接、查找等操作。
  ```cpp
  #include <string>
  std::string s = "Hello"; // C++ 特有
  s += " World";
  ```

---

### **3. 复数类型（`std::complex`）**
- **C 语言**：无原生复数支持。
- **C++**：标准库提供 `std::complex` 类型。
  ```cpp
  #include <complex>
  std::complex<double> c(1.0, 2.0); // 实部1.0，虚部2.0
  ```

---

### **4. 长整型（`long long`）**
- **C 语言**：C99 标准引入 `long long`，但部分编译器可能不支持。
- **C++**：`long long` 是标准类型（64位整数），且 `long` 的大小可能因平台而异（32/64位）。
  ```cpp
  long long big_num = 123456789012345LL; // C++ 特有
  ```

---

### **5. 强枚举（`enum class`）**
- **C 语言**：传统枚举成员作用域全局，易冲突。
  ```c
  enum Color { RED, GREEN }; // RED/GREEN 污染全局命名空间
  ```
- **C++**：C11 引入强枚举（`enum class`），成员作用域限定在枚举类内。
  ```cpp
  enum class Color { RED, GREEN }; // 需用 Color::RED 访问
  ```

---

### **6. 空指针（`nullptr`）**
- **C 语言**：用 `NULL`（通常定义为 `0` 或 `(void*)0`），可能引发隐式转换问题。
- **C++**：引入 `nullptr`（`std::nullptr_t` 类型），避免类型混淆。
  ```cpp
  int* p = nullptr; // C++ 特有
  ```

---

### **7. 类型推导（`auto`）**
- **C 语言**：不支持。
- **C++**：C11 引入 `auto`，编译器自动推导类型。
  ```cpp
  auto x = 5;        // x 为 int
  auto y = 3.14;     // y 为 double
  ```

---

### **8. 智能指针**
- **C 语言**：手动管理内存（`malloc`/`free`）。
- **C++**：提供智能指针自动管理内存：
  - `std::unique_ptr`：独占所有权。
  - `std::shared_ptr`：共享所有权（引用计数）。
  - `std::weak_ptr`：弱引用，避免循环引用。
  ```cpp
  #include <memory>
  std::unique_ptr<int> p = std::make_unique<int>(10); // C++14 特有
  ```

---

### **9. 容器类型**
- **C 语言**：原生数组和手动内存管理。
- **C++**：标准库提供容器（如 `std::vector`、`std::array`）。
  ```cpp
  #include <vector>
  std::vector<int> v = {1, 2, 3}; // 动态数组
  ```

---

### **10. 类型别名（`using`）**
- **C 语言**：仅支持 `typedef`。
- **C++**：支持更清晰的 `using` 语法（尤其用于模板）。
  ```cpp
  typedef int MyInt;        // C/C++ 均支持
  using MyInt = int;        // C++ 特有
  ```

---

### **11. 模板（`template`）**
- **C 语言**：不支持泛型编程。
- **C++**：支持函数/类模板，实现泛型代码。
  ```cpp
  template<typename T>
  T max(T a, T b) { return a > b ? a : b; }
  ```

---

### **总结对比表**
| 特性                | C 语言                     | C++                          |
|---------------------|---------------------------|------------------------------|
| 布尔类型            | 无（用 `int`）            | `bool`                       |
| 字符串              | 字符数组（`char*`）       | `std::string`                |
| 复数                | 无                        | `std::complex`               |
| 长整型              | C99 支持（可选）          | `long long`（标准）          |
| 枚举                | 全局作用域                 | `enum class`（强作用域）     |
| 空指针              | `NULL`（可能冲突）        | `nullptr`（类型安全）        |
| 类型推导            | 无                        | `auto`                       |
| 内存管理            | 手动（`malloc`/`free`）   | 智能指针（`unique_ptr`等）   |
| 容器                | 原生数组                  | `std::vector`/`std::array`   |
| 类型别名            | `typedef`                 | `using`（更灵活）            |
| 泛型编程            | 无                        | `template`                   |

---
